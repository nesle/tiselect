#!/usr/bin/env python

# TIS (terminal inline select) is a graphical chooser for the terminal that
# avoids taking over the whole screen or using an alternate screen.  I could
# not make this work using curses (which could explain why there are so few
# such tools), so I do stuff using termios and hard-coding.
#
# I look up what I can from terminfo and you're probably wondering why I don't
# look up the rest of it that way as well.  As it turns out, on my system for
# example (Linux, xterm), the escape code generated by arrow key down (^[[B) is
# simply not listed anywhere in the xterm definition.
#
# If arrow keys don't work on your term, use 'a'/'z' or 'k'/'j' (from vi).
#
# This script talks directly to /dev/tty so you can use it in scripting with
# for example `choice=$(tis a b c)` or `tis * | xargs dosomething`.
#
# DONE: Handle lists longer than terminal (scrolling?)
# DONE: Box
# TODO: Options
# TODO: Paddings, themes (colours?)
# TODO: Header text
# TODO: Python3

import termios, select, os, sys, curses, fcntl, struct

class TISelectDrawing:
    def __init__(self, term):
        if term['acsc'] and term['smacs'] and term['rmacs']:
            self.asc = True
        else:
            self.asc = False
        self.drawing_tab = {
            'ulcorner':     ['+', 'l'],
            'urcorner':     ['+', 'k'],
            'hline':        ['-', 'q'],
            'vline':        ['|', 'x'],
        }
    def draw_top(self):
        pass

class TISelectTerminal:
    def __init__(self):
        curses.setupterm()
        _ti = curses.tigetstr
        self.term = {
            'up':       ['\33[A', _ti('kcuu1')],
            'down':     ['\33[B', _ti('kcud1')],
            't_up':     _ti('cuu1'),
            'home':     [_ti('home'), _ti('khome')],
            'end':      ['\33[F', _ti('kend')],
            'pgup':     _ti('kpp'),
            'pgdn':     _ti('knp'),
            'enter':    '\n',
            'reverse':  _ti('rev'),
            'normal':   _ti('sgr0'),
            'c_invis':  _ti('civis'),
            'c_normal': _ti('cnorm'),
            'acsc':     _ti('acsc'),
            'smacs':    _ti('smacs'),
            'rmacs':    _ti('rmacs')
        }
        if self.term['c_invis']:
            self.term['c_invis'] += '\r'
        self.tty_in = open('/dev/tty', 'rb+', 0)
        self.tty_out = open('/dev/tty', 'wb+', 0)
        self.get_terminal_size()
    def __getitem__(self, item):
        return self.term[item]
    def get_terminal_size(self):
        self.h, self.w, _, _ = struct.unpack('HHHH',
            fcntl.ioctl(self.tty_out, termios.TIOCGWINSZ,
                struct.pack('HHHH', 0, 0, 0, 0)))

class TISelect:
    def __init__(self, items, box=False, title=None):
        self.items = items
        self.box = box
        self.title = title
        self.term = TISelectTerminal()
        self.selected = 0
        self.width = min(max(map(len, self.items)), self.term.w - 6)
        self.height = min(len(items), self.term.h / 3)
        if self.height < len(items):
            self.scrollbar = True
        else:
            self.scrollbar = False
    def ptty(self, stuff):
        self.term.tty_out.write(stuff)
    def draw_item(self, item):
        if len(item) > self.width:
            return item[:self.width-3] + '...'
        else:
            return item
    def visible(self, n):
        start = self.selected - self.height/2
        end = (self.selected + (self.height+1)/2) - 1
        if start < 0:
            end += -start
            start = 0
        if end > len(self.items)-1:
            start -= end - (len(self.items)-1)
            end = len(self.items)-1
        return start <= n <= end
    def draw_scrollbar(self, n):
        lineno = round((self.height-1) *
                       (self.selected / float(len(self.items)-1)))
        if lineno == n:
            return self.term['reverse'] +'#'+ self.term['normal']
        else:
            return '|'
    def draw(self, rewind=True, no_selection=False):
        real_height = self.height
        box_l = box_r = ""
        if self.box:
            box_l = "|"
            if not self.scrollbar:
                box_r = "|"
            real_height += 2
        if rewind:
            self.ptty(self.term['t_up'] * real_height + "\n")
        fmt = "%%s%%s %%-%ds %%s%%s" % self.width
        count = 0
        if self.box:
            #self.ptty('+' + '-'*(self.width+2) + '+' + "\n")
            self.ptty(self.term['smacs'] + 'l' + 'q'*(self.width+2) + 'k' + self.term['rmacs'] + "\n")
        for i, item in enumerate(self.items):
            if not self.visible(i):
                continue
            it = self.draw_item(item)
            if i == self.selected and not no_selection:
                self.ptty(fmt % (box_l, self.term['reverse'], it, self.term['normal'], box_r))
            else:
                self.ptty(fmt % (box_l, "", it, "", box_r))
            if self.scrollbar:
                self.ptty(self.draw_scrollbar(count))
            if count < self.height-1:
                self.ptty("\n")
            count += 1
        if self.box:
            self.ptty('\n+' + '-'*(self.width+2) + '+')
    def update(self):
        stuff = os.read(self.term.tty_in.fileno(), 512)
        if stuff in ['a', 'k'] + self.term['up']:
            self.selected = max(0, self.selected-1)
        elif stuff in ['z', 'j'] + self.term['down']:
            self.selected = min(len(self.items)-1, self.selected+1)
        elif stuff in self.term['home']:
            self.selected = 0
        elif stuff in self.term['end']:
            self.selected = len(self.items)-1
        elif stuff in ('-', self.term['pgup']):
            self.selected = max(0, self.selected - self.height)
        elif stuff in (' ', self.term['pgdn']):
            self.selected = min(len(self.items)-1, self.selected + self.height)
        elif stuff == self.term['enter']:
            self.ptty("\n")
            print self.items[self.selected]
            sys.exit(0)
        else:
            return
        self.draw()
    def run(self):
        old = termios.tcgetattr(self.term.tty_in)
        new = termios.tcgetattr(self.term.tty_in)
        new[3] = new[3] & ~(termios.ECHO | termios.ICANON)

        try:
            termios.tcsetattr(self.term.tty_in, termios.TCSADRAIN, new)
            if self.term['c_invis']:
                self.ptty(self.term['c_invis'])
            self.draw(False)
            while True:
                r, _, _ = select.select([self.term.tty_in], [], [])
                assert(r == [self.term.tty_in])
                self.update()
        finally:
            termios.tcsetattr(self.term.tty_in, termios.TCSADRAIN, old)
            if self.term['c_invis'] and self.term['c_normal']:
                self.ptty(self.term['c_normal'])

if __name__ == '__main__':
    if len(sys.argv) < 3:
        sys.exit("Usage: %s <item1> <item2> [<item3> [...]]" % sys.argv[0])
    tis = TISelect(sys.argv[1:], box=True)
    try:
        tis.run()
    except KeyboardInterrupt:
        # On interrupt, redraw with no selection, so a glance at the backlog
        # does not give the impression that an action was chosen.
        tis.draw(no_selection=True)
        tis.ptty("\n")
        sys.exit(1)
