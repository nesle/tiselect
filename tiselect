#!/usr/bin/env python

# TIS (terminal inline select) is a graphical chooser for the terminal that
# avoids taking over the whole screen or using an alternate screen.  I could
# not make this work using curses (which could explain why there are so few
# such tools), so I do stuff using termios and hard-coding.
#
# I look up what I can from terminfo and you're probably wondering why I don't
# look up the rest of it that way as well.  As it turns out, on my system for
# example (Linux, xterm), the escape code generated by arrow key down (^[[B) is
# simply not listed anywhere in the xterm definition.
#
# If arrow keys don't work on your term, use 'a'/'z' or 'k'/'j' (from vi).
#
# This script talks directly to /dev/tty so you can use it in scripting with
# for example `choice=$(tis a b c)` or `tis * | xargs dosomething`.
#
# DONE: Handle lists longer than terminal (scrolling?)
# DONE: Box
# DONE: Options
# TODO: Paddings, themes (colours?)
# DONE: Header text
# TODO: Python3
# TODO: Searching?
# DONE: Unicode string width

import termios, select, os, sys, curses, fcntl, struct, argparse

class TerminalInfo:
    def __init__(self):
        curses.setupterm()
        def _ti(cap):
            # Why does python's curses not expose tputs?!  We can't use putp!
            # For now, just strip delay stuff, print it ourselves, and hope it
            # works.
            string = curses.tigetstr(cap)
            if string:
                idx = string.find('$<')
                if idx != -1:
                    return string[:idx]
            return string
        self.term = {
            'up':       ['\33[A', _ti('kcuu1')],
            'down':     ['\33[B', _ti('kcud1')],
            't_up':     _ti('cuu1'),
            'home':     [_ti('home'), _ti('khome')],
            'end':      ['\33[F', _ti('kend')],
            'pgup':     _ti('kpp'),
            'pgdn':     _ti('knp'),
            'enter':    '\n',
            'reverse':  _ti('rev'),
            'bold':     _ti('bold'),
            'normal':   _ti('sgr0'),
            'c_invis':  _ti('civis'),
            'c_normal': _ti('cnorm'),
            'acsc':     _ti('acsc'),
            'smacs':    _ti('smacs'),
            'rmacs':    _ti('rmacs'),
            'escape':   '\33'
        }
        # ACS is weird, from what I can understand, the string gives, in pairs,
        # the VT100 character, documented in terminfo(5), followed by the
        # character for this terminal (so for VT100 they're identical pairs).
        acsc = self.term['acsc']
        self.acs_table = {}
        if acsc:
            for i in range(0, len(acsc)-1, 2):
                self.acs_table[acsc[i]] = acsc[i+1]
        if self.term['c_invis']:
            self.term['c_invis'] += '\r'
        # OpenBSD and FreeBSD both choked on a single read-write file handle,
        # so now they're separate handles for input and output.
        self.tty_in = open('/dev/tty', 'rb+', 0)
        self.tty_out = open('/dev/tty', 'wb+', 0)
        self.get_terminal_size()
    def __getitem__(self, item):
        return self.term[item]
    def get_terminal_size(self):
        self.h, self.w, _, _ = struct.unpack('HHHH',
            fcntl.ioctl(self.tty_out, termios.TIOCGWINSZ,
                struct.pack('HHHH', 0, 0, 0, 0)))
        if self.h == 0:
            self.h = 24
        if self.w == 0:
            self.w = 80
    def has_full_acs(self):
        return all(map(lambda x: x in self.acs_table,
                       ['l', 'k', 'q', 'x', 'm', 'j']))

# Dirty hack to get the right width of things that happen to be UTF-8 without
# having to decode and recode everything through the system.  This still
# returns the wrong results for mixed-charset strings (ie binary junk).  I see
# no easy way around that.
def mylen(string):
    try:
        return len(string.decode('utf-8'))
    except UnicodeDecodeError:
        return len(string)

class TISelect:
    def __init__(self, items, opts):
        self.items = items
        self.opts = opts
        self.box = opts.box
        self.title = opts.title or ""
        self.term = TerminalInfo()
        if not self.term['t_up']:
            sys.exit("Error: Terminal has no cursor up capability.")
        self.selected = 0
        self.width = min(max(map(mylen, self.items + [self.title])),
                         self.term.w - 6)
        if mylen(self.title) > self.width:
            self.title = self.title[:self.width-3] + '...'
        if opts.height:
            self.height = min(len(items), opts.height, self.term.h)
        else:
            self.height = min(len(items), self.term.h / 3)
        if (self.height < len(items) and not opts.no_scrollbar) or opts.scrollbar:
            self.scrollbar = True
        else:
            self.scrollbar = False
        self.draw_init()
    def ptty(self, stuff):
        self.term.tty_out.write(stuff)
    def crop_item(self, item):
        if mylen(item) > self.width:
            return item[:self.width-3] + '...'
        else:
            return item
    def visible(self, n):
        start = self.selected - self.height/2
        end = (self.selected + (self.height+1)/2) - 1
        if start < 0:
            end += -start
            start = 0
        if end > len(self.items)-1:
            start -= end - (len(self.items)-1)
            end = len(self.items)-1
        return start <= n <= end
    def draw_init(self):
        if self.term.has_full_acs() and self.term['smacs']\
           and self.term['rmacs'] and not self.opts.ascii:
            self.acs = True
        else:
            self.acs = False
        self.drawing_tab = {
            'ulcorner':     ['+', 'l'],
            'urcorner':     ['+', 'k'],
            'hline':        ['-', 'q'],
            'vline':        ['|', 'x'],
            'llcorner':     ['+', 'm'],
            'lrcorner':     ['+', 'j']
        }
    def draw_char(self, char_name):
        if self.acs:
            return self.term.acs_table[self.drawing_tab[char_name][1]]
        else:
            return self.drawing_tab[char_name][0]
    def draw_start(self):
        if self.acs:
            return self.term['smacs']
        else:
            return ''
    def draw_stop(self):
        if self.acs:
            return self.term['rmacs']
        else:
            return ''
    def draw_title(self, box=False):
        if box:
            self.ptty(' ' + (self.term['bold'] or '*') +
                      self.title +
                      (self.term['normal'] or '*') + ' ')
        else:
            pad = ((self.width + 2) - mylen(self.title)) / 2
            self.ptty(' ' * pad +
                      (self.term['bold'] or '*') +
                      self.title +
                      (self.term['normal'] or '*') +
                      "\n")
    def draw_box_top(self):
        if self.title:
            padl = ((self.width + 2) - (mylen(self.title) + 2)) / 2
            padr = padl
            if padl + padr + mylen(self.title) + 2 != self.width + 2:
                padr += 1
            self.ptty(self.draw_start() +
                      self.draw_char('ulcorner') +
                      self.draw_char('hline') * padl +
                      self.draw_stop())
            self.draw_title(box=True)
            self.ptty(self.draw_start() +
                      self.draw_char('hline') * padr +
                      self.draw_char('urcorner') +
                      self.draw_stop() +
                      "\n")
        else:
            self.ptty(self.draw_start() +
                      self.draw_char('ulcorner') +
                      self.draw_char('hline') * (self.width + 2) +
                      self.draw_char('urcorner') +
                      self.draw_stop() +
                      "\n")
    def draw_box_bottom(self):
        self.ptty("\n" +
                  self.draw_start() +
                  self.draw_char('llcorner') +
                  self.draw_char('hline') * (self.width + 2) +
                  self.draw_char('lrcorner') +
                  self.draw_stop())
    def draw_box_left_side(self):
        self.ptty(self.draw_start() +
                  self.draw_char('vline') +
                  self.draw_stop())
    def draw_box_right_side(self):
        # Identical, for now.
        self.draw_box_left_side()
    def draw_item(self, item, selected=False):
        if selected and self.term['reverse']:
            start = self.term['reverse'] + " "
            stop = " " + self.term['normal']
        elif selected:
            start = "*"
            stop = "*"
        else:
            start = " "
            stop = " "
        fmt = "%s%%-%ds%s" % (start, self.width, stop)
        self.ptty(fmt % item)
    def draw_rewind(self):
        real_height = self.height
        if self.box:
            real_height += 2
        elif self.title:
            real_height += 1
        self.ptty(self.term['t_up'] * real_height + "\n")
    def draw_scrollbar(self, n):
        lineno = round((self.height-1) *
                       (self.selected / max(1, float(len(self.items)-1))))
        if self.term['reverse'] and lineno == n:
            self.ptty(self.term['reverse'] + '#' + self.term['normal'])
        elif lineno == n:
            self.ptty('#')
        else:
            self.draw_box_right_side()
    def draw(self, rewind=True, no_selection=False):
        if rewind:
            self.draw_rewind()
        count = 0
        if self.box:
            self.draw_box_top()
        elif self.title:
            self.draw_title(box=False)
        for i, item in enumerate(self.items):
            if not self.visible(i):
                continue
            it = self.crop_item(item)
            if self.box:
                self.draw_box_left_side()
            if i == self.selected and not no_selection:
                self.draw_item(it, selected=True)
            else:
                self.draw_item(it)
            if self.scrollbar:
                self.draw_scrollbar(count)
            elif self.box:
                self.draw_box_right_side()
            if count < self.height-1:
                self.ptty("\n")
            count += 1
        if self.box:
            self.draw_box_bottom()
    def update(self):
        stuff = os.read(self.term.tty_in.fileno(), 512)
        if stuff in ['a', 'k'] + self.term['up']:
            self.selected = max(0, self.selected-1)
        elif stuff in ['z', 'j'] + self.term['down']:
            self.selected = min(len(self.items)-1, self.selected+1)
        elif stuff in self.term['home']:
            self.selected = 0
        elif stuff in self.term['end']:
            self.selected = len(self.items)-1
        elif stuff in ('-', self.term['pgup']):
            self.selected = max(0, self.selected - self.height)
        elif stuff in (' ', self.term['pgdn']):
            self.selected = min(len(self.items)-1, self.selected + self.height)
        elif stuff == self.term['enter']:
            self.ptty("\n")
            print self.items[self.selected]
            sys.exit(0)
        elif stuff == self.term['escape']:
            raise KeyboardInterrupt
        else:
            return
        self.draw()
    def run(self):
        old = termios.tcgetattr(self.term.tty_in)
        new = termios.tcgetattr(self.term.tty_in)
        new[3] &= ~(termios.ECHO | termios.ICANON)

        try:
            termios.tcsetattr(self.term.tty_in, termios.TCSADRAIN, new)
            if self.term['c_invis']:
                self.ptty(self.term['c_invis'])
            self.draw(False)
            while True:
                r, _, _ = select.select([self.term.tty_in], [], [])
                assert(r == [self.term.tty_in])
                self.update()
        finally:
            termios.tcsetattr(self.term.tty_in, termios.TCSADRAIN, old)
            if self.term['c_invis'] and self.term['c_normal']:
                self.ptty(self.term['c_normal'])

def main():
    parser = argparse.ArgumentParser(description=
        """tiselect (terminal inline select) is a screen-oriented chooser for
           the command line.  It aims to fit into the natural flow of the
           command line, rather than taking over the whole terminal view like
           most dialog(1) equivalents do.  tiselect communicates with /dev/tty
           and prints the result to standard output, making it easy to use from
           scripts.""")
    pa = parser.add_argument
    pa('items', nargs='+', metavar='<items>',
       help="Items to choose between.")
    pa('-b', '--box', dest='box', action='store_true',
       help="Surround chooser with a box.")
    pa('-s', '--scrollbar', dest='scrollbar', action='store_true',
       help="Always display a scrollbar, even if the list fits on screen.")
    pa('-S', '--no-scrollbar', dest='no_scrollbar', action='store_true',
       help="Never display a scrollbar, even if scrolling is needed.")
    pa('-t', '--title', dest='title', metavar='<title>',
       help="Display a title before the choices.")
    pa('-H', '--height', dest='height', metavar='<height>', type=int,
       help="Specifies a max height in lines (default: 1/3 of term size).")
    pa('-a', '--ascii', dest='ascii', action='store_true',
       help="ASCII drawing characters only.")
    args = parser.parse_args()

    tis = TISelect(args.items, args)
    try:
        tis.run()
    except KeyboardInterrupt:
        # On interrupt, redraw with no selection, so a glance at the backlog
        # does not give the impression that an action was chosen.
        tis.draw(no_selection=True)
        tis.ptty("\n")
        sys.exit(1)

if __name__ == '__main__':
    main()
